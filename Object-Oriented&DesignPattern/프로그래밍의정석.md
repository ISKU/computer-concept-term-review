# 프로그래밍의 정석
지식의 토대
# 전제 - 프로그래밍 불변의 사실  
## 프로그래밍에서 만능은 없다
* ### What? 특효약은 없다 - 상황에 맞게

* ### Why? 소프트웨어는 본질적으로 난해하다
  * 복잡성
  * 동조성(호환성) <br>
  소프트웨어는 실세계와 계속 동조해야한다
  * 가변성(변경 가능성)
  * 비가시성  
* ### How? 역사를 배워 복잡함에 맞선다<br>
  착실하고 과학적인 접근법에 근거하여 개선해야한다.<br>
  소프트웨어 본질은 난해성이며 최대 요인은 복잡함에 있다.<br> 소프트웨어 개발 역사는 사실 복잡함과 투쟁의 역사
* ### improve 소프트웨어의 비본질적인 부분을 개선
  * 부차적이고 부수적인 것들 ex) 빌드환경, 프로그래밍 언어, 라이브러리, 프레임워크  이들을 자동화해서 본질적인 부분에 시간을 더 할애하자  

## 코드는 설계서다
* ### What? 코드가 곧 설계서
  설계의 결과물인 설계서가 코드다.<br>
  제조에 해당하는 공정은 배포와 빌드다. <br>컴파일러와 빌드 시스템이 수행하는 것
* ### Why? 개선 대상은 코드다
  기본 설계, 상세 설계, 프로그래밍, 테스트, 디버깅은 나눌 수 없는 한 묶음의 작업 단위다. 서로 연계되어있다.
* ### How? 우수한 설계자(=프로그래머)가 필요
  * 프로그래밍은 창조적인 행위
  한 묶음의 작업이라면 그런 작업을 분담하는 것이 바람직한 방식은 아니다. 모든 프로그래머가 사양을 작성하고 코드를 작성해야한다.  
  * 프로그래밍 언어에 종속되지 않은 설계 표기를 나중에 누군가가 코드로 변환시키보다는 설계자 본인이 직접하는게 제대로된 방식
  * 코드 작성을 가능한 빨리 시작해야 불명확한 부분을 채우고 설계가 완성된다.
* 로제타 스톤 - 문서도 중요하다  
  * 장래의 유지보수 담당자에게 필요한 가이드북
  * 소프트웨어 아키텍처에 ㅎ관해서 전체를 파악하기 위해 필요한 그림을 기술 and 설계 이유(why)를 작성
## 코드는 반드시 변경된다
* ### What? 코드는 수정되는 법, 일회용으로 쓰고 버리는 경우는 우선 없다.
* ### Why? 코드는 무상하다
  * 본질적으로 복잡하며 완벽해질 수 없다.
  * 배포된 후에 반드시 오류가 발생하고 문제를 해결해야한다. 기능을 확장할 때도 있다. 최초 배포만으로 요구사항을 완전히 망라한 소프트웨어를 만들어 내는 것은 불가능하다.
* ### How? 변경에 강한 코드를 작성한다.
  * 읽기 쉬워야한다.

# 원칙 - 프로그래밍 가이드 라인
## KISS -Keep It Simple, Stupid /Keep It Short and Simple
  * ### What? 코드는 단순하게 유지한다.
  * ### Why? 코드는 무질서로 향한다.
    * 코드는 반드시 변경이 된다.
    * 단순한 코드는 구성하는 각 요소가 모두 단순하고 각 요소가 담당하는 기능도 최소한으로 한정되어 있다.
  * ### How? 코드에 불필요한 것을 하지 않는다.<br>
    불필요한 것을 키우는 마인드
    * 새롭게 배운 기술을 사용하고 싶다
    * 장래의 필요에 대비하고 싶다
    * 멋대로 요구사항을 추가한다
    요구사항을 결정하는 건 사용자다
  * ### KISS 적용 범위<br>
    기능만 많고 복잡한 소프트웨어는 결국 사용하지 않는다. 기능과 인터페이스를 단순하게 유지하면 사용하기 쉽고 많이 사용하는 소프트웨어가 된다.
  * ### 오컴의 면도날<br>
  '어떤 사항을 설명하는데 필요 이상으로 많은 전제를 가정해서는 안된다는 사고방식' 여러 설명이 가능하다면 가장 단순한 방식이 옳다는 뜻

## DRY - Don't Repeat Yourself 중복하지 마라
* What? 코드 복사는 금물
* 코드를 개선할 수 없다.
* 레거시 코드 : 테스트가 없는 코드// 예전에는 만들어진 이해할 수 없고 변경 어려운 코드에서 재정의
## YAGNI - You Aren't Going to Need it
* What? 코드는 필요할 때 최소한으로, 정말로 필요해졌을 때 필요한 코드만을 작성한다는 방침  
* 코드의 예측은 빗나간다.
* 코드는 지금 필요한 것만
*
## PIE - Program Intently and Expressively
* What? 코드의 의도를 전한다.
* 코드가 유일한 실마리
* 코드는 읽기 쉬운 것이 최우선
* 두더지 잡기식 개발을 피한다
* 주석을 작성한다. - 코드는 what, how 밖에 표현 못하므로
* 문화적 프로그래밍
 코드 자체를 문서화하는 기법, 코드는 스토리처럼 작성

## SLAP - Single Level of Abstraction Principle
* What? 코드 수준을 맞춘다. (추상)
코드를 작성할 때 높은 수준의 추상화 개념과 낮은 수준의 추상화 개념을 분리하도록 한다. <br>

```
function 고수준(){
  중수준1();
  중수준2();
}
function 중수준1(){
  저수준1();
  저수준2();
}
function 저수준1(){
  //처리
}
```
* 코드에 요약성과 열람성을 가져다준다.
* 함수를 구조화한다
* 의도가 구조
* SLAP의 순서
  - <Strong>내용을 쓰는 것과 내용을 이해하기 쉽게 전하기 위한 구성을 생각하는 것</Strong>은 별개
* 코드와 책의 유사성
  * 서문 : 책의 요지, 파일 첫머리 주석  
  * 목차 // 함수 목록, ide가 제공하니 불필요
  * 섹션 : 모듈 단위 기술
  * 장 : 구조화한 함수
  * 단락 : 코드 블록
  * 문장 : 실제 구현, 간결해야
  * 상호 참조 및 색인

## OCP - Open-Closed Principle
코드의 변경은 파급시키지 않는다

## 명명이 중요하다

# 사상 - 프로그래밍 이데올로기
* 프로그래밍 이론
* 아키텍처 비기능 요구사항
* 7가지 설계 원리
* UNIX 사상
* UNIX 철학

# 관점 - 프로그래머가 보는 시각
'이런 관점으로 생각하고 이런 요소를 고려해 두면 나중에 좋다'

# 습관 - 프로그래머의 일상

# 기법 - 프로그래머의 도구 상자

# 법칙 - 프로그래밍 안티 패턴
소프트웨어를 개발할 때 빠지기 쉬운 함정들
